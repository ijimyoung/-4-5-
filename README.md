코어 자바 스크립트 4,5강
✍️ 공부 내용 정리
10장 객체 리터럴
10-1. 객체란?
JS는 객체 기반 프로그래밍 언어
원시 타입: 단 하나의 값만 나타냄, 변경 불가
객체 타입: 다양한 타입의 값을 하나의 단위로 구성한 자료구조, 변경 가능한 값
객체 구성: 프로퍼티 키, 프로퍼티 값 -> 프로퍼티의 집합
모든 값은 프로퍼티 값이 될 수 있음
프로퍼티 값이 함수일 경우 메서드
var counter = {
  // 프로퍼티: 객체의 상태를 나타내는 값
  num: 0,
  // 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작
  increase: function () {
    this.num++;
  },
};
10-2. 객체 리터럴에 의한 객체 생성
클래스 기반 객체지향 언어
사전에 클래스를 생성하고 new + 생성자로 인스턴스 생성하는 방식으로 객체 생성
C++, JAVA
프로토타입 기반 객체지향 언어 (JS)
다양한 객체 생성 방법 지원
객체 리터럴: 가장 기본적, 유연하고 강력함, new 연산자 + 생성자 X, 동적 프로퍼티 추가 등..
(Object) 생성자 함수, Object.create, 클래스 ..
변수 할당 시점에 객체 리터럴이 해석되어 객체를 생성함
10-3. 프로퍼티
프로퍼티 키: 모든 문자열 또는 심벌 값
빈 문자열 포함 but 키의 역할을 하지 못함
암묵적 타입 변환으로 문자열이 됨
중복 키 선언 시 에러 발생하지 않고 기존 프로퍼티를 덮어씀
프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값
10-4. 메서드
함수는 객체 -> 함수는 값 -> 프로퍼티 값 사용 가능 -> 메서드: 객체에 묶여있는 함수

var circle = {
  radius: 5, // ← 프로퍼티

  // 원의 지름
  getDiameter: function () {
    // ← 메서드
    return 2 * this.radius; // this는 circle을 가리키는 참조변수
  },
};

console.log(circle.getDiameter()); // 10
10-5. 프로퍼티 접근
객체에 존재하지 않는 key 접근 시 undefined 반환, ReferenceError 발생 X
10-8. 프로퍼티 삭제
delete 연산자: 존재하지 않는 프로퍼티 삭제 시 에러 없이 무시됨
10-9. 객체 리터럴 확장 기능
프로퍼티 키 동적 생성

ES5 이전: 객체 외부에서 프로퍼티 키 동적 생성
ES6 이후: 객체 내부에서 프로퍼티 키 동적 생성 가능
메서드 축약 표현

ES5 이전: 메서드 정의 시 프로퍼티 값으로 함수 할당
ES6 이후: 메서드 정의 시 function 생략 가능 -> 프로퍼티에 할당한 함수와 다르게 동작함
// ES6
const obj = {
  name: "Lee",
  // 메서드 축약 표현
  sayHi() {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Lee
11장 원시 값과 객체의 비교
원시 값과 객체는 크게 세 가지 측면에서 다르다 -> 변경 여부, 메모리 공간에 저장되는 값, 변수 할당 시 전달되는 형태

11-1. 원시 값
변경 불가능한 값 (읽기 전용)
데이터의 신뢰성 보장
값의 불변성
원시 값을 할당한 변수에 원시 값을 재할당하면 -> 원시 값은 변경 불가능하므로, 새로운 메모리 공간 확보하여 값을 저장한 후 변수에 새롭게 할당한 원시 값을 가리킴 (메모리 공간 주소를 바꿈)
만약 변경 가능하다면, 주소는 그대로고 주소 안의 값이 변경되었을 것 -> 즉 원시 값을 할당한 변수는 재할당이 변수 값을 변경하는 유일한 방법
문자열과 불변성
JS에서 문자열은 원시 타입이며 변경 불가함.
문자열은 유사 배열 객체 및 이터러블 -> 배열과 유사하게 각 문자에 접근할 수 있지만 변경 불가
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = "S";

console.log(str); // string
값에 의한 전달
변수에 원시 값 변수를 할당 시 할당 되는 원시 값이 복사되어 전달 -> 값에 의한 전달
변수들은 같은 값을 가지나, 값은 서로 다른 메모리에 저장된 별개의 값임. 할당 후 서로 영향을 주지 않음
엄밀히 하자면 메모리 주소가 전달되는 것!
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy); // 100  80
console.log(score === copy); // false
11-2. 객체
원시 값처럼 메모리 공간 크기 사전 정의 불가: 프로퍼티가 동적이므로
객체 생성 및 관리는 복잡하고 비용이 많이 들어 변경 가능한 값으로 설계하여 단점을 완화시킴
여러 개의 식별자가 하나의 객체 공유 가능해서 부작용할 수 있음
변경 가능한 값
객체(참조) 타입의 값은 변경 가능함
원시 값 할당 변수의 메모리 주소를 따라가면 원시 값 자체를 값으로 가짐
객체 값 할당 변수의 메모리 주소를 따라가면 참조 값에 접근함 -> 그 값이 저장되어 있는 주소를 가짐 -> 참조하여 실제 객체에 접근
재할당 없이 프로퍼티 동적 추가, 삭제, 변경 가능 -> 변수의 참조 값은 변경되지 않음
/**
 * - 얕은 복사: 한 단계까지 복사 (원시 값)
 * - 깊은 복사: 중첩된 객체까지 모두 복사본을 만듦 (객체)
 */

const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require("lodash");
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
참조에 의한 전달
객체 변수를 할당하면 원본의 참조 값이 복사되어 전달 -> 참조에 의한 전달
여러 개의 객체가 하나의 객체 공유 가능 -> 프로퍼티 변경 시 서로 영향을 받음
